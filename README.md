# Blazor_SourceGen_Demo
Demo purposes. Source gen logic removed.

Это решение содержит в себе клиентскую и серверную часть приложения по учету деятельности организации. Информационная структура подобна структуре информационной базы в 1С.

Демо версия доступна по https://dreamydarwin.Netlify.com. Для входа используйте логин techadmin без пароля. Новые пользователи создаются уполномоченным пользователем. После создания пользователь не имеет пароля и может его установить через Change password в выпадающем меню пользователя сверху справа. 
Серверная часть размещена на Heroku в виде Докер образа. Из-за своей бесплатности хостинг не дает высоких скоростей ни в обработке, ни в отправке информации, но несмотря на это не тормозит значительно.
Можно запустить на локальном компьютере. Для этого запустите отдельно Web.Server и Web.Client через dotnet run. 

-----------------------------------------------------------------------------------------------------------------------------------------------------

Общие изюминки:

  1. Кодогенерация на основе Roslyn анализатора. Во время сборки каждого проекта, к которому подключен анализатор, запускается процесс сбора информации по семантической 
    составляющей этого проект и при помощи Razor движка рендерится код, который записывается в новый файлы в решении. Файлы могут добавляться в другие проекты внутри решения.
    В оригинальной задумке Roslyn генерируемый код добавляется в оперативную память, но в связи с его большим объемом и необходимость добавлять его в контекст других проектов,
    не создавать новые файлы нельзя.
    Общая цель кодогенерации - это создать кодовую базу с CRUD операциями на основе схемы данных на клиенте и сервере, с которой можно работать без дополнительной работы, так как логика крудов сильно предсказуема. Тем не менее, сгенерированный код можно свободно менять - и даже нужно, так как он создан именно для создания основы с базовыми операциями.   
  
  2. Общение клиента с сервером в обе стороны происходит по протоколу GRPC при использовании технологии GRPC-Web (разработано для браузеров). Файлы GRPC с сообщениями и сервисами генерируются автоматически при сборке. 
    Сообщения - при сборке Data, сервисы - при сборке Web.Server на основе существующих статических методов, помеченных атрибутом, либо имеющих специальный параметр. 
    При наличии такого метода, описанного на сервере, автоматически создается соответствующий метод у клиентского сервиса с такими же входными параметрами для вызова 
    серверного метода.
  
  3. Клиентское и серверное кэширование. Каждый серверный метод может иметь атрибуты, указывающие, нужно ли применять кэш и его Expiration time (сколько он будет действителен 
  для переиспользования). Если для входящего параметра уже была выполнена такая операция в течение времени действия кэша на клиенте, то запрос не будет послан и будет возвращено
  значение того вызова. Реализация этого механизма описана в классах Asynchronous и Syncronous dispatchers в проекте Common. Аналогично с серверной стороной. Если с таким      параметром  операция уже выполнялась, то вычислений не будет и вернется имеемое актуальное значение. Это аналогично [ResponseCache] в ASP .Net MVC, но в плюс здесь параметром запроса может быть и сложный,  "многоэтажный" объект и его проверка будет такой же многоуровневой, а также проверку кэша можно (и нужно) использовать из любого места кода, так как   сгенерированные методы, которые сначала проверяют кэш, так же статические. Одним словом, не нужно отдельно для каждого вычисления описывать логику кэширования со своим ключом  и алгоритом проверки на эквивалентность входных параметров. Кэш хранится в оперативной памяти; имеет вместительность, которая указывается для каждого метода отдельно в атрибуте  ClientCaching/ServerCaching. 
  
  4. Механизм фильтрации записей на клиенте и сервере при помощи автосгенерированных фильтров. Для каждой сущности существует открытый метод, который принимает объект - фильтр, в котором указаны критерии сущности, которые должны выполняться одновременно, чтобы эта сущность попала в результирующий список. 

  5. Переброс серверных исключений на клиента. Если в процессе выполнения серверного метода выброшено исключение - наследник класса HandledException и оно не обработано, Pipeline создаст сообщение, в которое положит тип этой ошибки и ее сообщение, после чего получивший такое сообщение клиент воссоздаст объект ошибки и выбросит AggregateException, внутри которого будет лежать дубликат серверного исключения. Если исключение не является наследником HandledException, на клиенте будет выброшено исключение
ServerUnhadledException. Каждый метод вызова серверного метода по умолчанию работает так и не нужно дополнительно прописывать такую логику.   
  
  6. Имеется структура разрешений на каждую сущность по операциям, указанным в атрибутах этой сущности и ее родителей. Если пользователей, например, посетит страницу без разрешения на операцию "See", он увидит только "Access denied". 
 
  ------------------------------------------------------------------------
  
  Клиентские изюминки.
  
  1. Blazor WASM - само по себе большое преимущество такого решения. Не Asp .Net Core Hosted, поэтому легко размещается как отдельное статическое приложение, например, на Netlify. 

  2. Загрузка списков объектов таблицах происходит с пагинцией, но скрытой, т.е. объекты подгружаются порциями (по умолчанию по 10) в количестве, которое видно пользователю при
    данном уровне прокрутки. Реализовано при помощи компонента Virtualize. Подкрепляется клиентским кэшированием, поэтому количество запросов при прокрутке туда-сюда будет намного меньше.
  
  3. Компоненты, зависящие от схемы данных, сгенерированы автоматически. Процесс редактирования сущностей и полей, ссылающихся на другие сущности, очень прост, сводится к выбору
  объектов из фильрованного списка по пункту 4 сверху.
  
  4. Имеет все возможности превратиться в Blazor Hybrid со всеми вытекающими преимуществами.

  5. Имеет базовый функционал добавления пользователей, логина и изменения пароля.

