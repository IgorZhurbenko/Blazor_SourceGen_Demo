# Blazor_SourceGen_Demo
Demo purposes. Source gen logic removed.

Это решение содержит в себе клиентскую и серверную часть приложения по учету деятельности организации. Информационная структура подобна структуре информационной базы в 1С.

Изюминки:
  1. Кодогенерация на основе Roslyn анализатора. Во время сборки каждого проекта, к которому подключен анализатор, запускается процесс сбора информации по семантической 
    составляющей этого проект и при помощи Razor движка рендерится код, который записывается в новый файлы в решении. Файлы могут добавляться в другие проекты внутри решения.
    В оригинальной задумке Roslyn генерируемый код добавляется в оперативную память, но в связи с его большим объемом и необходимость добавлять его в контекст других проектов,
    не создавать новые файлы нельзя.
  2. Общение клиента с сервером в обе стороны происходит по протоколу GRPC при использовании технологии GRPC-Web (разработано для браузеров). Файлы GRPC с сообщениями и сервисами генерируются автоматически при сборке. 
    Сообщения - при сборке Data, сервисы - при сборке Web.Server на основе существующих статических методов, помеченных атрибутом, либо имеющих специальный параметр. 
    При наличии такого метода, описанного на сервере, автоматически создается соответствующий метод у клиентского сервиса с такими же входными параметрами для вызова 
    серверного метода.
  3. Клиентское и серверное кэширование. Каждый серверный метод может иметь атрибуты, указывающие, нужно ли применять кэш и его Expiration time (сколько он будет действителен 
  для переиспользования). Если для входящего параметра уже была выполнена такая операция в течение времени действия кэша на клиенте, то запрос не будет послан и будет возвращено
  значение того вызова. Реализация этого механизма описана в классах Asynchronous и Syncronous dispatchers в проекте Common. Аналогично с серверной стороной. Если с таким параметром
  операция уже выполнялась, то вычислений не будет и вернется имеемое актуальное значение. Это аналогично [ResponseCache] в ASP .Net MVC, но в плюс здесь параметром запроса 
  может быть и сложный,  "многоэтажный" объект и его проверка будет такой же многоуровневой, а также проверку кэша можно (и нужно) использовать из любого места кода, так как 
  сгенерированные методы, которые сначала проверяют кэш, так же статические. Одним словом, не нужно отдельно для каждого вычисления описывать логику кэширования со своим ключом
  и алгоритом проверки на эквивалентность входных параметров. Кэш хранится в оперативной памяти; имеет вместительность, которая указывается для каждого метода отдельно в атрибуте
  ClientCaching/ServerCaching.
  4. 
